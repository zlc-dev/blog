---
import type { AplayerAudio } from '../utils/aplayer';
import { createHash } from "node:crypto";
import '../styles/aplayer.css'

interface Props {
    lrc_type: 1 | 2 | 3;
    audio: AplayerAudio[];
    id?: string;
    cacheable?: boolean;
};

const { lrc_type, audio, id: id_, cacheable = true } = Astro.props;

const id = id_ ?? import.meta.env.DEV ? 
    `aplayer-${createHash("sha1").update(JSON.stringify(audio)).digest("hex")}`
    : `aplayer-${crypto.randomUUID()}`;


---
<div
    id={id} class="aplayer-inlined-container"
></div>

<style>
    .aplayer-inlined-container {
        background: transparent;
    }
</style>

<script type="module" define:vars={{ lrc_type, audio, id, cacheable }} is:inline data-astro-rerun>
    import 'https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js';

    class RetiredCache {
        constructor(capitaty = 8) {
            this.map = new Map();
            this.capitaty = capitaty;
        }

        get(id) {
            if (!this.has(id)) return null;
            const value = this.map.get(id);
            this.map.delete(id);
            this.map.set(id, value);
            return value.player;
        }
    
        full() {
            return this.map.size >= this.capitaty;
        }

        empty() {
            return this.map.size == 0;
        }

        pop() {
            if (this.empty()) return null;
            const [id, oldest] = this.map.entries().next().value;
            this.map.delete(id);
            return oldest;
        }

        has(id) {
            return this.map.has(id);
        }

        push(id, player, ondestroy) {
            if (this.map.has(id)) {
                this.map.delete(id);
            } else if (this.full()) {
                let oldest = this.pop();
                if (!oldest) {
                    ondestroy();
                    return;
                }
                oldest.ondestroy();
            }
            this.map.set(id, {player, ondestroy});
        }
    }

    let ap = null;

    function initAPlayer() {
        const container = document.getElementById(id);
        if (!container) return;
        let cached = window.__retaired_aplayers__.get(id);
        if (cached) {
            ap = cached;
            container.appendChild(ap.container);
        } else {
            ap = new APlayer({
                container,
                audio,
                autoplay: false,
                lrcType: lrc_type,
                theme: "var(--color-accent)"
            })
        }
    }

    function destroyAPlayer() {
        if (ap) {
            ap.pause();
            let ondestroy = () => {
                ap.destroy();
                document.removeEventListener("astro:before-swap", destroyAPlayer);
            };
            if (cacheable) {
                window.__retaired_aplayers__.push(id, ap, ondestroy);
            } else {
                ondestroy();
            }
        }
    }

    window.__retaired_aplayers__ ??= new RetiredCache();

    initAPlayer();
    if(!window.__retaired_aplayers__.has(id)) {
        document.addEventListener("astro:after-swap", destroyAPlayer);
    }

</script>

